<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html lang="en"> 
  
  <head>
    <title>Building whitening filters (LTPDA Toolbox)</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <meta name="description" content="Presents an overview of the features, system requirements, and starting the toolbox." />
    <link rel="stylesheet" href="docstyle.css" type="text/css" />
  </head>
  
  <body>
    <a name="top_of_page" id="top_of_page"></a>
    
    <p style="font-size:1px;">&nbsp;</p>
    
    <table class="nav" summary="Navigation aid" border="0" width="100%" cellpadding="0" cellspacing="0">
      <tr>
        <td valign="baseline"><b>LTPDA Toolbox&trade;</b></td>
        <td><a href="../helptoc.html">contents</a></td>
        <td valign="baseline" align="right"><a href="ltpda_training_2_topic_5_6_2.html"><img src="b_prev.gif" border="0" align="bottom" alt="Linear Parameter Estimation with Singular Value Decomposition"></a>&nbsp;&nbsp;&nbsp;<a href="ltpda_training_2_topic_5_6_2_2.html"><img src="b_next.gif" border="0" align="bottom" alt="Linear Parameter Estimation"></a></td>
      </tr>
    </table>
    
    <h1 class="title">Building whitening filters</h1>
    <hr>
    
    <p>
      <p>
  Whitening filters can be constructed from power spectral density (PSD) of 
  noise only data series. The procedure can be summarized in few steps:
  <ol>
    <li>Get noise only data</li>
    <li>Etimate PSD</li>
    <li>Obtain a smoothed version of your PSD estimation</li>
    <li>Use the smoothed PSD to calculate the whitening filter</li>
  </ol>
</p>

<p>
  The process starts with the doenload of noise only data.
  
  <div class="fragment"><pre>
    noise = matrix(<span class="string">'noise.mat'</span>);
  </pre></div>
  
</p>

<p>
  Assuming the noise is stationary we calculate whitening filter from the
  noise only part of the first experiment.
  
  <div class="fragment"><pre>
    [n1, n2] = noise(1).unpack;
  </pre></div>
</p>

<p>
  Whitening filter will be calculated from the noise spectra. We assume
  that the correlations between the two data series are so low that they
  cannot be properly identified by a cpsd estimation. Therefore we
  calculate two independent whitening filters for the two output channels. 
  This is equivalent to assume uncorrelated data.
  
  <div class="fragment"><pre>
    n1x = n1.lpsd;
    n2x = n2.lpsd;
  </pre></div>
  
  We are going to split in order to remove low frequency window corrupted data-points,
  
  <div class="fragment"><pre>
    n1xx = split(n1x, plist(<span class="string">'samples'</span>, [6 numel(n1x.y)]));
    n2xx = split(n2x, plist(<span class="string">'samples'</span>, [6 numel(n2x.y)]));
  </pre></div>
  
  and finally plot to check results.
  
  <div class="fragment"><pre>
    iplot(n1xx, n2xx)
  </pre></div>
  
  <div align="center">
    <IMG src="images/ltpda_training_2/Topic5/topic_5_6_2_1_no1.png"  align="center" border="0" width="70%">
  </div>
</p>

<p>
  Since the amount of data is limited, we do not properly cover low
  frequency with the estimated spectrum. We need to exted low frequency
  part in order to avoid that the fit would introduce unwanted features in a
  sensible frequency range (e.g. if we skip this part we end-up with a
  notch on channel 1 that will be clearly visible in the whitened time
  series).
  
  <div class="fragment"><pre>
    xt = [logspace(-5, log10(4.5e-4), 60)]';
    
    level1 = n1xx.y(1) .* 0.90;
    yt1 = ones(numel(xt),1) .* level1;

    level2 = n2xx.y(1) .* 3.00;
    yt2 = ones(numel(xt),1) .* level2;
  </pre></div>
  
  and generate an AO from them.
  <div class="fragment"><pre>
    yunit  = n1xx.yunits;
    fs     = n1xx.fs;    
    ext1   = ao(plist(<span class="string">'XVALS'</span>, xt, <span class="string">'YVALS'</span>, yt1, <span class="string">'TYPE'</span>, <span class="string">'FSDATA'</span>, <span class="string">'YUNITS'</span>, yunit, <span class="string">'FS'</span>, fs));
    ext2   = ao(plist(<span class="string">'XVALS'</span>, xt, <span class="string">'YVALS'</span>, yt2, <span class="string">'TYPE'</span>, <span class="string">'FSDATA'</span>, <span class="string">'YUNITS'</span>, yunit, <span class="string">'FS'</span>, fs));
  </pre></div>
  
  Original data and extension can be joint now.
  
  <div class="fragment"><pre>
    nn1xx = join(ext1, n1xx);
    nn2xx = join(ext2, n2xx);
  </pre></div>
  
  The resulting spectrum che be checked with a plot.
  
  <div class="fragment"><pre>
    iplot(nn1xx, nn2xx)
  </pre></div>
  
  <div align="center">
    <IMG src="images/ltpda_training_2/Topic5/topic_5_6_2_1_no2.png"  align="center" border="0" width="70%">
  </div>
</p>

<p>
  In order to obtain a smooth version of the calculated PSD we perform a 
  frequency domain fit with the 'ao' class method 'sDomainFit', which output
  a 'parfrac' object that can be used to define the input for our whitener.
  
  <div class="fragment"><pre>
      
      plfit = plist(...
                <span class="string">'AUTOSEARCH'</span>, <span class="string">'on'</span>, ...
                <span class="string">'STARTPOLESOPT'</span>, <span class="string">'clog'</span>, ...
                <span class="string">'maxiter'</span>, 30, ...
                <span class="string">'minorder'</span>, 4, ...
                <span class="string">'fittol'</span>, 1e-2, ...
                <span class="string">'msevartol'</span>, 5e-1, ...
                <span class="string">'plot'</span>, <span class="string">'off'</span>);
      
      s1 = sDomainFit(nn1xx,plfit);
      
      
      
      plfit = plist(...
                <span class="string">'AUTOSEARCH'</span>, <span class="string">'on'</span>, ...
                <span class="string">'STARTPOLESOPT'</span>, <span class="string">'clog'</span>, ...
                <span class="string">'maxiter'</span>, 30, ...
                <span class="string">'minorder'</span>, 3, ...
                <span class="string">'fittol'</span>, 1e-2, ...
                <span class="string">'msevartol'</span>, 5e-1, ...
                <span class="string">'plot'</span>, <span class="string">'off'</span>);
      
      s2 = sDomainFit(nn2xx,plfit);
  
  </pre></div>
</p>

<p>
  Frequency series 'aos' can be constructed from the 'parfrac' objects.
  They will be used as input to 'buildWhitener'.
  
  <div class="fragment"><pre>
    plr  = plist(<span class="string">'f'</span>,logspace(-5, log10(5), 5000)); <span class="comment">% define plist with frequency grid</span>

    rs1  = s1.resp(plr); <span class="comment">% get frequency response from parfarc object</span>
    mod1 = abs(rs1); <span class="comment">% this is a model for a psd, so it must be real</span>

    rs2  = s2.resp(plr); <span class="comment">% get frequency response from parfarc object</span>
    mod2 = abs(rs2); <span class="comment">% this is a model for a psd, so it must be real</span>

    iplot(mod1,mod2)
    
  </pre></div>
  
  <div align="center">
    <IMG src="images/ltpda_training_2/Topic5/topic_5_6_2_1_no3.png"  align="center" border="0" width="70%">
  </div>
  
</p>

<p>
  We are now ready to build the whitening filters for the first and differential channels.
  'buildWhitener', build a whitening filter from a frequency series input and a 'plist'.
  The frequency series 'ao' should be representative of the one-sided
  psd of the noise we want to whiten. 'buildWhitener' perform a fit in
  the z-domain to the data in order to identify the coefficients (poles and residues)
  of a digital filter. 
  
  <div class="fragment"><pre>
    
    plw = plist(...
          <span class="string">'fs'</span>, fs,...
          <span class="string">'FITTOL'</span>, 1e-3);

    w1 = buildWhitener1D(mod1, plw);
    w2 = buildWhitener1D(mod2, plw);
    
  </pre></div>
  
  If you want more information about 'buildWhitener options, then type
  
  <div class="fragment"><pre>
  
    help ao/buildWhitener1D
    
  </pre></div>
  
  in MATLAB command window.
  
</p>

<p>
  Once we have the whitening filters, we can check their frequency response.
  It is good practice to ceck filters response on a frequency grid tighter
  than that used for buildind the filter.
  
  <div class="fragment"><pre>
  
    plr = plist('f', logspace(-5, log10(5), 10000));

    rw1 = w1.resp(plr);
    rw2 = w2.resp(plr);

    iplot(rw1,rw2)
    
  </pre></div>
  
  <div align="center">
    <IMG src="images/ltpda_training_2/Topic5/topic_5_6_2_1_no4.png"  align="center" border="0" width="70%">
  </div>
  
  
  It is also interesting to check the behavior of the whitening filters on 
  the noise time series.
  
  <div class="fragment"><pre>
  
    nw1 = filter(n1, w1);
    nw2 = filter(n2, w2);

    iplot(nw1, nw2)
    
  </pre></div>
  
  <div align="center">
    <IMG src="images/ltpda_training_2/Topic5/topic_5_6_2_1_no5.png"  align="center" border="0" width="70%">
  </div>
  
  <div class="fragment"><pre>
  
    nw1xx = lpsd(nw1);
    nw2xx = lpsd(nw2);

    iplot(nw1xx, nw2xx)
    
  </pre></div>
  
  <div align="center">
    <IMG src="images/ltpda_training_2/Topic5/topic_5_6_2_1_no6.png"  align="center" border="0" width="70%">
  </div>
  
  As can be seen, the whitening is not perfect expecially at low frequency
  but enough to perform a meaningful fit.
  
</p>

<p>
  Once we are happy with our whitening filters, we can pack them in a matrix
  (diagonal) and save it. In order to have a diagonal filter matrix we will
  put empty filter objects out of the diagonal.
  
  <div class="fragment"><pre>
  
    <span class="comment">% out of diagonal filter</span>
    fil = filterbank(miir());

    <span class="comment">% build a matrix with whitening filters elements</span>
    wf = matrix(w1, fil, fil, w2, plist(<span class="string">'shape'</span>, [2 2]));
    
    wf.save(<span class="string">'whitening_filter.mat'</span>);
    
  </pre></div>
  
</p>



    </p>
    
    <br>
    <table class="nav" summary="Navigation aid" border="0" width="100%" cellpadding="0" cellspacing="0">
      <tr valign="top">
        <td align="left" width="20"><a href="ltpda_training_2_topic_5_6_2.html"><img src="b_prev.gif" border="0" align="bottom" alt="Linear Parameter Estimation with Singular Value Decomposition"></a>&nbsp;</td>
        <td align="left">Linear Parameter Estimation with Singular Value Decomposition</td>
        <td>&nbsp;</td>
        <td align="right">Linear Parameter Estimation</td>
        <td align="right" width="20"><a href="ltpda_training_2_topic_5_6_2_2.html"><img src="b_next.gif" border="0" align="bottom" alt="Linear Parameter Estimation"></a></td>
      </tr>
    </table>
    
    <br/>
    <p class="copy">&copy;LTP Team</p>
  </body>
  
</html>